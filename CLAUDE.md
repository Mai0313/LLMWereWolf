# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

LLM Werewolf is an AI-powered Werewolf (Mafia) game supporting 20+ roles with multiple LLM models. It features both a beautiful Terminal User Interface (TUI) using Textual and a console mode for auto-play. The project emphasizes extensibility, type safety with Pydantic, and structured event logging.

## Key Commands

### Development Setup

```bash
# Install dependencies
uv sync                      # Base dependencies only
uv sync --all-groups        # All dependencies (dev, test, docs)
uv sync --group dev         # Add development tools
uv sync --group test        # Add test dependencies

# Install pre-commit hooks
uv run pre-commit install
```

### Running the Game

```bash
# TUI Mode (Interactive)
uv run llm-werewolf-tui configs/demo.yaml              # With demo agents
uv run llm-werewolf-tui configs/demo.yaml --debug      # With debug panel
uv run werewolf-tui configs/players.yaml               # With LLM agents (requires API keys)

# Console Mode (Auto-play)
uv run llm-werewolf configs/demo.yaml
uv run werewolf configs/demo.yaml
```

### Testing

```bash
# Run all tests
uv run pytest

# Run with coverage report
uv run pytest --cov=src --cov-report=term-missing

# Run specific test file
uv run pytest tests/core/test_roles.py -v

# Run specific test function
uv run pytest tests/core/test_roles.py::test_werewolf_role -v

# Run tests in parallel (faster)
uv run pytest -n auto
```

### Code Quality

```bash
# Run linter checks
uv run ruff check src/

# Auto-fix linting issues
uv run ruff check --fix src/

# Format code
uv run ruff format src/

# Type checking
uv run mypy src/

# Run all pre-commit hooks
uv run pre-commit run --all-files

# Clean generated files
make clean
```

### Using Makefile

```bash
make help           # Show all available commands
make clean          # Clean autogenerated files
make fmt         # Run pre-commit hooks
make test           # Run all tests
make gen-docs       # Generate documentation
```

## Architecture Overview

### Core Game Flow (src/llm_werewolf/core/)

**GameEngine** (`game_engine.py`) is the central orchestrator:

- Manages complete game lifecycle from setup to victory
- Coordinates phase transitions: Night ‚Üí Day Discussion ‚Üí Voting ‚Üí Victory Check
- Executes role actions in strict priority order during night phase (see `ActionPriority` in `roles/base.py`)
- Processes voting and elimination during day phase
- Fires events through `EventLogger` for UI synchronization

**GameState** (`game_state.py`) maintains the current state:

- Tracks all players, their alive/dead status, and role states
- Manages game phase (Night, Day, Voting) and round counter
- Provides query methods for alive/dead players by faction
- Stores temporary state like night targets, protections, votes

**Action System** (`actions.py`):

- Abstract `Action` base class with `validate()` and `execute()` methods
- Concrete actions: `WerewolfKillAction`, `WitchSaveAction`, `SeerCheckAction`, `VoteAction`, etc.
- Each action validates game state before execution and returns result messages
- Actions are created by roles during their turn and executed by GameEngine

**Event System** (`events.py`):

- All game events are typed via `EventType` enum
- `Event` model includes timestamp, visibility scope, and structured data
- `EventLogger` maintains chronological event history
- Events drive both UI updates and game history tracking

**Victory Checking** (`victory.py`):

- Checked after each phase by `VictoryChecker`
- Conditions: Villagers win if all werewolves dead, werewolves win if >= villagers, lovers can win if only they remain
- Returns `VictoryResult` with winner faction and surviving players

### Role System (src/llm_werewolf/core/roles/)

**Base Role Architecture** (`base.py`):

- `Role` abstract class defines the contract: `get_config()`, `perform_night_action()`, `perform_day_action()`
- `RoleConfig` specifies camp, priority, action timing, and max uses
- `Camp` enum: WEREWOLF, VILLAGER, NEUTRAL
- `ActionPriority` enum defines night action order (higher executes first): Cupid(100) ‚Üí Guard(90) ‚Üí Werewolf(80) ‚Üí Witch(70) ‚Üí Seer(60) ‚Üí etc.

**Role Implementation Pattern**:

1. Each role inherits from `Role` and implements `get_config()`
2. Roles with night actions implement `perform_night_action(game_state) -> Action | None`
3. Roles with day actions implement `perform_day_action(game_state) -> Action | None`
4. Roles use `ActionSelector` to prompt AI agents and parse responses

**Role Categories**:

- `werewolf.py`: Werewolf faction roles (Werewolf, AlphaWolf, WhiteWolf, WolfBeauty, GuardianWolf, HiddenWolf, NightmareWolf, BloodMoonApostle)
- `villager.py`: Villager faction roles (Villager, Seer, Witch, Hunter, Guard, Idiot, Elder, Knight, Magician, Cupid, Raven, GraveyardKeeper)
- `neutral.py`: Neutral roles (Thief, Lover)

**Adding New Roles**:

1. Create role class in appropriate faction file
2. Define `RoleConfig` with camp, priority, and abilities
3. Implement action methods if the role has abilities
4. Register in `role_registry.py` `get_role_map()`
5. Add tests in `tests/core/test_roles.py`

### AI Agent System (src/llm_werewolf/ai/)

**Agent Types** (`agents.py`):

- `LLMAgent`: OpenAI-compatible API client using `openai` library
- `HumanAgent`: Terminal input for human players
- `DemoAgent`: Random canned responses for testing
- All agents implement: `get_response(message: str) -> str` and `model_name` attribute

**ActionSelector** (`action_selector.py`):

- Builds structured prompts for AI decision-making
- `build_target_selection_prompt()`: Creates numbered target lists
- `parse_target_selection()`: Extracts player selection from AI response with regex
- `build_yes_no_prompt()`: Binary decision prompts
- Handles both strict selections and optional "SKIP" actions

**Agent Creation Flow**:

1. YAML config defines players with model type
2. `PlayerConfig` validates required fields (base_url for LLMs, api_key_env)
3. `create_agent(PlayerConfig)` factory instantiates appropriate agent type
4. Agent is attached to `Player` object during game setup

### Configuration System (src/llm_werewolf/core/config/)

**GameConfig** (`game_config.py`):

- Defines game rules: player count, role composition, phase timeouts
- Validates role count matches player count
- Validates at least one werewolf exists
- Configurable settings: `allow_revote`, `show_role_on_death`, `enable_sheriff`

**Presets** (`presets.py`):

- Pre-configured game setups: `6-players`, `9-players`, `12-players`, `15-players`, `expert`, `chaos`
- Each preset specifies `num_players` and balanced `role_names` list
- Accessible via `get_preset_by_name(name: str) -> GameConfig`

**Player Configuration** (`ai/agents.py`):

- `PlayerConfig`: Per-player model config with name, model, base_url, api_key_env, temperature, max_tokens
- `PlayersConfig`: Root config with players list and preset name
- Loads from YAML with validation for unique names and player count

### UI Layer (src/llm_werewolf/ui/)

**TUI Application** (`tui_app.py`):

- Built with Textual framework for rich terminal UI
- Main app coordinates: PlayerPanel, GamePanel, ChatPanel, DebugPanel (optional)
- Subscribes to engine events to update UI in real-time
- Keyboard controls: 'q' quit, 'd' toggle debug, 'n' next step

**Components** (`ui/components/`):

- `player_panel.py`: Displays player list with status indicators (‚úì‚úóüõ°Ô∏è‚ù§Ô∏è‚ò†Ô∏èüî¥)
- `game_panel.py`: Shows current phase, round, faction counts, vote tallies
- `chat_panel.py`: Scrollable event log with color-coded messages
- `debug_panel.py`: Session info, config details, error tracking

**Console Mode** (`cli.py`):

- Auto-play mode without TUI
- Prints events as structured text with round/phase prefixes
- Useful for automated testing and CI

### Entry Points

**CLI Entry** (`cli.py`):

- `main(config: str)`: Loads YAML, creates engine, runs game in console mode
- Uses Fire library for command-line argument parsing
- Registered as `llm-werewolf` and `werewolf` commands

**TUI Entry** (`tui.py`):

- `main(config: str, debug: bool)`: Loads YAML, creates engine, launches TUI
- Registered as `llm-werewolf-tui` and `werewolf-tui` commands
- Debug flag or config `show_debug` controls debug panel visibility

## Project Structure Patterns

**Type Safety**:

- Heavy use of Pydantic models for data validation
- TYPE_CHECKING imports to avoid circular dependencies
- Type hints throughout with `str | None` union syntax

**Error Handling**:

- Logfire integration for structured logging (configured with `send_to_logfire=False`)
- Events logged with context: player_id, round, phase
- Errors logged with traceback in `logfire.error()` calls

**Testing Approach**:

- Tests organized by module: `tests/core/`, `tests/ai/`, `tests/config/`, `tests/integration/`
- Fixtures for common objects (players, game states, roles)
- Integration tests validate full game flow in `tests/integration/test_game_flow.py`
- Coverage target: 40% minimum (configured in pyproject.toml)

**Code Quality Standards**:

- Ruff for linting and formatting (Google-style docstrings)
- Max line length: 99 characters
- McCabe complexity: 18 max
- Pre-commit hooks enforce style before commits

## Environment Configuration

Create `.env` file with API keys:

```bash
OPENAI_API_KEY=sk-...
ANTHROPIC_API_KEY=sk-ant-...
DEEPSEEK_API_KEY=sk-...
XAI_API_KEY=xai-...
```

## Important Implementation Notes

1. **Role Action Order Matters**: Night actions execute by priority enum value. When adding roles with night actions, assign appropriate priority to ensure correct sequencing (e.g., Guard protects before Werewolves attack).

2. **Event Visibility**: Events can be scoped to specific players via `visible_to` field. Werewolf discussions are only visible to werewolves. Use `None` for public events.

3. **Agent Prompting**: ActionSelector builds structured prompts with numbered options. AI responses are parsed with regex to extract selections. Always include clear instructions and handle malformed responses gracefully.

4. **Game State Immutability**: GameState methods return new collections, not direct references. Actions modify state through dedicated methods like `mark_player_dead()`, `add_vote()`, etc.

5. **Async Considerations**: While code includes async patterns (pytest-asyncio configured), current implementation is primarily synchronous. Future async support is planned for concurrent AI calls.

6. **Logfire Configuration**: Logfire is configured but not sending data to cloud (`send_to_logfire=False`). Used for structured local logging and debugging. Important: Configure logfire BEFORE other imports to ensure proper instrumentation.

7. **Testing with DemoAgent**: Use `model: demo` in YAML configs for fast deterministic testing without LLM API calls.

8. **YAML Config Validation**: Pydantic validates configs on load. Errors include helpful messages about mismatched player counts, invalid roles, or missing required fields.
